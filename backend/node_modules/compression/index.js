const zlib = require('zlib');

function parseThreshold(value) {
  if (typeof value === 'string') {
    const match = value.match(/^(\d+)(kb)?$/i);
    if (match) {
      return parseInt(match[1], 10) * (match[2] ? 1024 : 1);
    }
  }
  return typeof value === 'number' ? value : 0;
}

module.exports = function compression(options = {}) {
  const threshold = parseThreshold(options.threshold);
  const level = options.level ?? zlib.constants.Z_DEFAULT_COMPRESSION;
  const filter = options.filter || (() => true);

  return function (req, res, next) {
    const accept = req.headers['accept-encoding'] || '';
    if (!/\bgzip\b/.test(accept) || !filter(req, res)) {
      return next();
    }

    const chunks = [];
    const originalWrite = res.write.bind(res);
    const originalEnd = res.end.bind(res);
    res.setHeader('Vary', 'Accept-Encoding');

    res.write = (chunk, encoding, cb) => {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding));
      if (cb) cb();
    };

    res.end = (chunk, encoding, cb) => {
      if (chunk) {
        chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding));
      }
      const buffer = Buffer.concat(chunks);
      if (buffer.length < threshold) {
        originalWrite(buffer);
        return originalEnd(cb);
      }
      zlib.gzip(buffer, { level }, (err, compressed) => {
        if (!err) {
          res.setHeader('Content-Encoding', 'gzip');
          originalWrite(compressed);
        } else {
          originalWrite(buffer);
        }
        originalEnd(cb);
      });
    };

    next();
  };
};
